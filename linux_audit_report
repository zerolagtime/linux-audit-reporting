#!/bin/bash
##### UNCLASSIFIED ##########
## Written by Charlie Todd <zerolagtime@gmail.com>
## LICENSE: GPL 2.0
## Copyright 2019 by Charlie Todd

# Purpose: Satisfy auditing requirements on standalone Linux systems
#   Note that STIG-compliant auditing must be configured for these reports
#   to have meaningful data.
# Description:
#   If the user has sudo privilege on the system to execute the aureport command,
#   then "sudo aureport <options>" is run multiple times to produce a report
#   in the local folder.  If no reports exist, then an audit review is done
#   for the last $daysBack days.  If successful audit review reports are
#   in the same folder, then this audit review will be set to start from
#   the moment that last report was first started.  This should provide
#   continuous coverage in the event that an irregular schedule is followed.

reportFileOnly="$(date +%Y%m%d_%H%M%S)-${HOSTNAME/\.*/}-audit_report.txt"
reportLocation="$(dirname $0)/archive"
reportFile="$reportLocation/$reportFileOnly"
offlineArchiveFolder=""
daysBack=7
maxDaysBack=365
ME="${SUDO_USER:-$USER}"
GlobalErrors=0
GlobalWarnings=0


MYTEMP=${TEMP:-/tmp/$ME}
if [ ! -d $MYTEMP ]; then
   mkdir $MYTEMP
   chown $USER $MYTEMP
   chmod 700 $MYTEMP
fi

function stderr { 
   echo "$*" 1>&2 
}

function usage {
   stderr "Usage: $(basename $0) [-y daysback] [-d archive_dir] [-f]"
   stderr "                      [-a offline_folder]"
   if [ "$1" == "long" ]; then
      stderr "Purpose: Generate a weekly report of all \"organization-defined"
      stderr "         auditable events for CNSS 1253 and JSIG AU-2."
      stderr "         Also, it archives the supporting, raw audit events"
      stderr "         next to the report for easy archiving over NFS/SCP."
      stderr "Options:"
      stderr "  -y daysback            (default $daysBack)"
      stderr "     Start the review this many days back.  If left unset,"
      stderr "     the report starts $daysBack days ago, unless existing"
      stderr "     reports exist.  If existing reports exist, the most recent,"
      stderr "     and successful report will be used as the starting time"
      stderr "     so as to ensure continuous coverage back to the last report." 
      stderr "  -d archive_dir         (default $reportLocation)"
      stderr "     Directory to place reports and gzipped copies of audit"
      stderr "     records used to produce the report."
      stderr "  -a offline_folder      (default is no offline copies)"
      stderr "     A copy of the report and supporting logs will be copied here"
      stderr "     if the review is successful."
      stderr "  -f"
      stderr "     Force the script to keep exiting when checking on baseline"
      stderr "     configuration problems, which might normally cause the script"
      stderr "     to exit until the configuration is fixed.  Note that using"
      stderr "     force might compromise a future investigate when critical"
      stderr "     was not audited despite the requirement to do so."
   fi
   exit 1 
}

while getopts "hfy:d:a:" o; do
   case "${o}" in
      y) 
         daysBack=${OPTARG}
         [ -n "$daysBack" ] && [ "$daysBack" -ge 0 ] && \
         [ "$daysBack" -le $maxDaysBack ] || {
	    stderr "-y must be between 0 and $maxDaysBack";
	    usage
         }
	 ;;
      d)
         reportLocation=${OPTARG} 
         [ -n "$reportLocation" ] && [ -d "$reportLocation" ] && \
         [ -w "$reportLocation" ] || {
	    stderr "-d requires a writeable directory";
	    usage
         }
	 ;;
      f)
         force="yes"
         ;;
      a) 
         offlineArchiveFolder=${OPTARG}
         [ -n "$offlineArchiveFolder" ] && [ -d "$offlineArchiveFolder" ] && \
         [ -w "$offlineArchiveFolder" ] || {
            stderr "-a requires a writeable directory";
            usage
         }
         ;;
      h) usage long ;;
      *) usage long ;;
   esac
done
shift $((OPTIND-1))
# this really only applies to the default location as any
# user specified location must already exist
if [ ! -d "$reportLocation" ]; then
   mkdir "$reportLocation" || {
      stderr "Cannot create the directory $reportLocation.  Exiting"
      exit 1
   }
fi

CYAN=$(echo -e "\033[0;36m")
LCYAN=$(echo -e "\033[36m")
YELLOW=$(echo -e "\033[0;33m")
LYELLOW=$(echo -e "\033[33m")
LIGHT_CYAN=$(echo -e "\033[1;36m")
NO_COLOUR=$(echo -e "\033[0m")
RED=$(echo -e "\033[1;37m\033[40m")
BRED=$(echo -e "\033[1;37m\033[41m")
GREEN=$(echo -e "\033[1;37m\033[42m")

function checkLoggedInAsRoot {
   if [ "$USER" == "root" -a -z "$SUDO_USER" ]; then
       stderr "${RED}ALERT: This tools should be run as you.${NO_COLOUR}" 
       stderr "       Do not login in such a way that you use the root password." 
       stderr "       Exiting this script." 
       echo "ALERT: audit review aborted because the user did not log in as themselves" > $reportFile
       stderr "${YELLOW}Suggestion:${NO_COLOUR} If this report is part of an investigation,"
       stderr "       use the force option (-f) to run the report anyway."
       stderr "       Alternatively, just review the interpreted audit log with"
       stderr "          ausearch -ts 1/1/1970 --format text"
       stderr "       and draw your own conclusions."
       return 2
   fi
}


# if the user has sudo privileges, return 0.  Otherwise, return a non-zero value
# If they fail to authenticate, that also counts against them
function checkSudoPrivileges {
   allowed=$(/bin/sudo --prompt="Checking to see if you have sudo privileges.
[sudo] password for ${USER}: " --list )
   return $?
}

function AUREPORT {
   if [ $(whoami) != "root" ]; then
       /bin/sudo /usr/sbin/aureport $*
   else
       aureport $* 
   fi
   return $?
}

function AUSEARCH {
   if [ $(whoami) != "root" ]; then
       /bin/sudo /usr/sbin/ausearch $*
   else
       ausearch $* 
   fi
   return $?
}

function lpad {
   cat | sed -e 's/^/    /'
}

function oopsChecker {
   catUsed=0
   quiet=0
   
   if [ "$1" == "-v" ]; then
      catUsed=1
      shift 1
   fi
   if [ $# -gt 0 ]; then
      msg="$*"
   else
      msg=$(cat)
      catUsed=1
   fi
   if [[ $msg == *"WARNING"* ]]; then
      GlobalWarnings=$[ $GlobalWarnings + 1 ]
   elif [[ $msg == *"ERROR"* ]]; then
      GlobalErrors=$[ $GlobalErrors + 1 ]
   fi
   if [ $catUsed -eq 1 ] ; then
      echo "$msg" | awk -v CYAN=${CYAN} -v RED=${RED} -v NC=${NO_COLOUR} \
               -v BRED=${BRED} '
          /^=====/ { print CYAN $0 NC; next }
          /WARNING/ { print RED $0 NC; next }
          /ERROR/   { print BRED $0 NC; next }
          { print $0 }
      '
   fi
}

exec 8> >(while read a; do echo "$a" >&2; echo "$a"  |  sed -e 's/\x1b\[[^m]*m//g;'; done >> $reportFile;  ) 
# Write output to the screen and a logfile
function reportLine {
   if [ $# -gt 0 ]; then
       oopsChecker "$*" >&8
       #echo "$*" >> $reportFile
   else
       #strip the coloring, but still analyze for warnings/errors
       #oopsChecker | sed -e 's/\x1b\[[^m]*m//g;' >> $reportFile
       oopsChecker >&8
   fi
}

function reportAndScreenLine {
   if [ $# -gt 0 ]; then
       oopsChecker -v "$*" >&8
       #echo "$*" >> $reportFile
   else
       #oopsChecker | tee -a $reportFile
       oopsChecker >&2
   fi
}

set -x
date | reportLine
ps -ef | reportLine
exit 0
# use this function like this:
#    testImportantCondition || unlessForced || failAndExit
function unlessForced {
   if [ "$force" == "yes" ]; then
      reportLine "NOTICE: there were errors and the script was run with"
      reportLine "        the force (-f) option to continue anyway."
      reportLine "        Continued use of force may result in critical information"
      reportLine "        not being audited which may hinder a future investigation."
      return 0
   fi
   return 1
}

function getSudoOrExit {
   checkSudoPrivileges
   if [ $? -ne 0 ]; then
      reportAndScreenLine "You have no sudo privileges, or don't know the password.  Exiting."
      exit 1
   fi
}

function getNewestReportDate {
   # returns a string in aureport friendly time format MM/DD/YYYY HH:MM:ss
   # unless --fileSafe is a parameter, in which case it is YYYYMMDD_hhmmss
   # note that newest file is this log file, so the second newest
   dateFormat="%m/%d/%Y %H:%M:%S"
   if [ "$1" == "--fileSafe" ]; then
       dateFormat="%Y%m%d_%H%M%S"
   fi
   files=$(cd "$reportLocation";
       /bin/ls -1t *-${HOSTNAME/\.*/}-audit_report.txt 2>/dev/null)
   for report in $files; do
       tail -1 $report 2>&1 | grep --silent "Audit Review Complete"
       if [ $? -eq 0 ]; then
           reportLine "Setting the audit start time from $report"
           fileDate=$(stat -c %Z $report) ; # time since change in epoch seconds
           auditDate=$(date -d @$fileDate +"$dateFormat")
           echo "$auditDate"
	   return
       else
           :
           #reportLine "Ignoring this report which never completed: $report"
       fi
   done
   #output nothing if no reports exist
}

# getAuditStart provides an ausearch/aureport friendly date
# either starting at the last report or $daysBack days ago (default 7 days)
# Format looks like "mm/dd/yyyy hh:mm:ss"
function getAuditStart {
   startDate=$(getNewestReportDate) 
   if [ -z "$startDate" ]; then
       startDate=$(date -d "$daysBack days ago" +"%m/%d/%Y %H:%M:%S")
   fi
   echo "$startDate"
}

# getAuditStartFileSafe provides an ausearch/aureport friendly date
# either starting at the last report or $daysBack days ago (default 7 days)
# Format looks like "yyyymmdd_hhmmss"
function getAuditStartFileSafe {
   startDate=$(getNewestReportDate --fileSafe) 
   if [ -z "$startDate" ]; then
       startDate=$(date -d "$daysBack days ago" +"%Y%m%d_%H%M%S")
   fi
   echo "$startDate"
}
function getScriptChecksum {
   cksum=$(cat $0 | sha256sum )
   lastModified=$(stat -c%y $0)
   thisPath=$(dirname $0)
   if [ "$thisPath" == "." ]; then
      thisPath=$(pwd)
   fi
   reportAndScreenLine "${LCYAN}This program:${NO_COLOUR}        ${thisPath}/$(basename $0)"
   reportAndScreenLine "${LCYAN}This program checksum:${NO_COLOUR}     $cksum (SHA256)"
   reportAndScreenLine "${LCYAN}This program lastmodified:${NO_COLOUR} $lastModified"
}

function failAndExit {
   reportAndScreenLine "[ERROR]: There were problems with the last command.  Exit code $?"
   reportAndScreenLine "         The audit review is **NOT COMPLETE**.  Exiting."
   exit 1
}


function quickAuditCheck {
   failures=0
   service auditd status 2>/dev/null >/dev/null
   if [ $? -ne 0 ]; then
      echo "ERROR: auditd is not running on this host"
      failures=$[ $failures + 1 ]
   fi
   numRecords=$(sudo egrep -e '^(-a|-w) ' /etc/audit/audit.rules | wc -l)
   numRules=$(sudo bash -c "egrep -e '^(-a|-w) ' /etc/audit/rules.d/*" | wc -l)
   if [ -z "$numRecords" -o -z "$numRules" -o "$numRecords" -ne "$numRules" ]; then
      numDiff=$[ $numRules - $numRecords ]
      echo "ERROR: There were $numDiff unparsed audit rules in /etc/audit/rules.d"
      echo "       so auditing may be incomplete."
      if [ $numDiff -lt 0 ]; then
         echo "NOTE: Since the number is negative, rules have been manually added"
         echo "      to /etc/audit/audit.rules which will not survive a reboot."
      fi
      failures=$[ $failures + 1 ]
   fi
   if [ -z "$numRecords" -o "$numRecords" -lt 100 ]; then
      echo "ERROR: auditd is not adequately configured on this host"
      echo "       please apply the stig-disa-7 profile with oscap"
      failures=$[ $failures + 1 ]
   fi
   echo "A quick check to see that all rules are being implemented found $failures problems."
   return $failures
}

# return 0 if the file watch is in place with the specified permissions
function auditRuleCheckWatch {
   auditctlOutput="$1"
   param2="$2"
   param3="$3"
   file="${param2:-/var/log/audit/audit.log}"
   perm="${param3:-ra}"
   echo "$actl" |egrep --silent -e "^-w \"?$file\"? -p $perm" 
   res=$?
   if [ $res -ne 0 ]; then
      echo "WARNING: $file is not being watched by the audit daemon"
   fi
   return $res
}
# return 0 if auditing is configured to watch 
# the audit log files
function checkAuditLogWatch {
   actl=$(sudo auditctl -l)
   if [ -n "${actl}" ]; then
      {
          auditRuleCheckWatch "${actl}" /var/log/audit/audit.log && \
          auditRuleCheckWatch "${actl}" /var/log/secure && \
          auditRuleCheckWatch "${actl}" /var/log/tallylog && \
          auditRuleCheckWatch "${actl}" /var/log/lastlog 
      } || {
          sampleFile="01-security_log.rules"
          cat > "$sampleFile" << EOF
# meet CNSS/JSIG AU-2.a.9 - Audit and security relevant log data accesses
-w /var/log/secure -p ra -k security_log
-w /var/log/lastlog -p ra -k security_log
-w /var/log/tallylog -p ra -k security_log
-w /var/log/wtmp -p ra -k security_log
-w /var/log/audit/audit.log -p ra  -k security_log
EOF
          echo "=== ERROR: audit is not configured to fully"
          echo "===        record AU-2, specifically AU-2.a.9"
          echo "===        Copy $sampleFile to /etc/audit/rules.d"
          echo "===        and restart the audit daemon with"
          echo "===          sudo mv $sampleFile /etc/audit/rules.d && sudo service auditd restart"
          echo "=== Quick audit configuration check complete "
          return 1
      }
   else
      echo "WARNING: Could not get a list of current audit rules"
      return 1
   fi
   echo "Audit rules exist to monitor access to security-relevant logs"
   return 0
}

# return 0 if the audit log produces enriched output, 1 if not.
# enriched output automatically translates system calls and usernames
# in the raw log format - this is ideal for post-incident, offline analysis 
function checkAuditLogEnriched {
   cFile="/etc/audit/auditd.conf"
   aconf=$(sudo cat $cFile)
   if [ -n "${aconf}" ]; then
      format=$(echo "$aconf" | egrep "^ *log_format" | sed -e 's/.*=[ ]*//')
      if [ "$format" == "ENRICHED" ]; then
         return 0
      fi
      echo "WARNING: Please change the audit log daemon to enrich its logs"
      echo "         as this radically simplifies forensic analysis."
      echo "         Type the following at a prompt (a backup is kept)"
      echo "            sudo sed --in-place=.bak \\"
      echo "               -e 's/log_format.*/log_format = ENRICHED/' \\"
      echo "               $cFile && \\"
      echo "               sudo restorecon $cFile && \\"
      echo "               sudo service auditd restart"
      sleep 15
      return 1
   else
      echo "ERROR: The audit daemon is missing its configuration file"
      return 1
   fi
}

function getUsersWithBurnPrivileges {
   opticalMedia=$(/bin/ls -1 /dev/sr[0-9]*)
   if [ -n "$opticalMedia" ]; then
      ( for device in $opticalMedia; do
         deviceGroup=$(stat --printf "%G" $device)
         usersInGroup=$(getent group $deviceGroup | cut -d: -f4)
         echo "$usersInGroup" | sed -e 's/,/\n/g'
      done ) | sort | uniq
   fi 
}

# if passed a list of files that need audit reports, then 
# produce raw audit records on stdout where those files
# are mentioned.  This is a workaround for the fact that
# ausearch doesn't honor the --file option multiple times
# for a logical "OR"
function ausearchFileList {
   tmpResults=$MYTEMP/ausearch.$$.txt
   for oneFile in $*; do
      AUSEARCH $auditDateOptions --file $oneFile --format raw >> $tmpResults 2>/dev/null
   done 
   sort -k 2 $tmpResults | uniq
   rm $tmpResults
}

# if the wodim or similar RPMs are installed, someone determined that optical 
# media reading and writing were permissible.  If they were installed recently,
# of if this is a new system, we may have not added the auditing of those 
# programs to this system and/or report, so we provide a sample file
# that can be added to /etc/audit.d/rules.d.  Subsequent runs will
# report on usage of those executables.  
# Assumption: rules to watch files files use the audit keyword "media"
#   and may need to be adjusted if another application adds these watches
#   to the audit rules
function reviewCdTools {
   mediaPackages=$(rpm -qa wodim genisoimage libisofs fuseiso)
   filesToWatch=$(rpm -ql $mediaPackages | egrep -e "(/bin/|lib.*\.so)")
   if [ -n "$filesToWatch" ]; then
      actl=$(sudo auditctl -l)
      reportLine          "Note:             this system has tools to build ISOs, so"
      reportLine          "                  files could be exfiltrated this way as a bundle."
      unauditedFiles=""
      for watch in $filesToWatch; do
         auditRuleCheckWatch "${actl}" $watch 
         if [ $? -ne 0 ]; then
            unauditedFiles="$unauditedFiles
-w \"$watch\" -p x -k media" 
         fi
      done
      if [ -z "$unauditedfiles" ]; then
         reportAndScreenLine "WARNING: Optical media or image generation tools are not fully audited."
         sampleFile="02-media.rules"      
         if [ -f $sampleFile ]; then /bin/rm $sampleFile; fi
         # meet 800-53r4/JSIG AU-2.a.9 - Audit and security relevant log data accesses
         echo "# === improve CNSS/JSIG AU-2.a.3 Export/Write to digital media " >> $sampleFile
         echo "# === improve CNSS/JSIG AU-2.a.4 Import from digital media" >> $sampleFile
	 echo "$unauditedFiles">> $sampleFile
         reportAndScreenLine "Suggestion:       create a watch on optical media tools "
         reportAndScreenLine "                  by copying $sampleFile to /etc/audit.d/rules.d"
         reportAndScreenLine "                     sudo mv $sampleFile /etc/audit/rules.d && \\"
         reportAndScreenLine "                     sudo service auditd restart"
      fi
      reportLine          "Here are all the times that an ISO creation/burning tool was called."
      reportLine          "Note that if there is a warning above, then the audit rules are"
      reportLine          "not fully covered by audit rules. Reporting on the use of"
      reportLine          "$(echo "$filesToWatch" | wc -l) files on the watch list."
      ausearchFileList $filesToWatch | AUSEARCH --format text | lpad | reportLine || failAndExit
   fi
}

function daysBetween {
   sdateT="$1"
   edateT="$2"
   sdate=$(date --date="$sdateT" '+%s')
   edate=$(date --date="$edateT"   '+%s')
   days=$[ (edate - sdate) / 86400  ]
   echo "$days"
}

##############################################################################
##############################################################################
##############################################################################
##############################################################################
reportAndScreenLine "=================================================" 
reportAndScreenLine "${LCYAN}Audit review of:${NO_COLOUR}     ${HOSTNAME} on $(date)" 
reportAndScreenLine "${LCYAN}Review conducted by:${NO_COLOUR} ${ME}"
reportAndScreenLine "${LCYAN}This report:${NO_COLOUR}         $reportFileOnly" 
auditStart=$(getAuditStart)
auditEnd=$(date +"%m/%d/%Y %H:%M:%S")
archiveStart=$(getAuditStartFileSafe)
daysAgo=$(daysBetween "$auditStart" "$auditEnd" )
auditArchiveFile="$reportLocation/${HOSTNAME}-audit_archive-${archiveStart}_to_$(date +%Y%m%d_%H%M%S).log"
reportAndScreenLine "${LCYAN}Earliest audit date:${NO_COLOUR} $auditStart ($daysAgo days ago)"
reportAndScreenLine "${LCYAN}Latest audit date:${NO_COLOUR}   $auditEnd" 
reportAndScreenLine "${LCYAN}Archive audit file:${NO_COLOUR}  $auditArchiveFile"
getScriptChecksum
reportAndScreenLine "=================================================" 
sleep 1 
set -x
reportAndScreenLine "" 
checkLoggedInAsRoot || unlessForced || failAndExit
sleep 2
getSudoOrExit
set +x
auditDateOptions=" -ts $auditStart -te $auditEnd"
commonAuditOptions=" $auditDateOptions -i"

reportAndScreenLine "================================================="
reportAndScreenLine "=== Quick audit configuration check "
quickAuditCheck | lpad | reportLine || unlessForced || failAndExit
checkAuditLogWatch | reportAndScreenLine || sleep 15
checkAuditLogEnriched | reportAndScreenLine || unlessForced || failAndExit
reportAndScreenLine "=== Quick audit configuration check complete "
reportLine          "" 


reportAndScreenLine "================================================="
reportAndScreenLine "=== Archiving the audit records for integrity and to "
reportAndScreenLine "===    only record one access while writing this report"
AUSEARCH $auditDateOptions --raw > $auditArchiveFile
if [ $? -eq 0 ]; then
   reportAndScreenLine "=== Archiving complete"
   auditDateOptions="$auditDateOptions -if $auditArchiveFile"
   trap "echo \"Removing $auditArchiveFile on break\"; rm $auditArchiveFile; exit 2" 2 3 4 5 6 7 8 9 10 12 13 14
else 
   freeSpace=$(df -h --output=avail $(dirname $auditArchiveFile))
   reportAndScreenLine "ERROR: Archiving FAILED.  Exiting. $freeSpace left in folder."
   failAndExit 
fi

reportAndScreenLine "================================================="
reportAndScreenLine "=== AUDIT REPORT: Summary "
reportAndScreenLine "=== Description:  A brief overview of events "
AUREPORT $commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Summary " 
reportLine          "" 


reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Anomaly Events "
reportAndScreenLine "=== Description:  Strange events that should rarely occur "
AUREPORT   --anomaly $commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Anomaly Events " 
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: User Authorizations (FAILED) "
reportAndScreenLine "=== Description:  all events that show an account validation was"
reportAndScreenLine "===               attempted, but failed"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.1.(1) Logons (Failure)"
AUREPORT --auth --failed $commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: User Authorizations (FAILED)" 
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Login/Logout (SUCCESS)"
reportAndScreenLine "=== Description:  All events that show an account validation was"
reportAndScreenLine "===               attempted, and succeeded"
reportAndScreenLine "=== Note:         An unsuccessful logout is one that was"
reportAndScreenLine "===               forced during a reboot"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.1.(1) Logons (Success)"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.1.(2) Logouts (Success/Failure)"
#AUREPORT --auth --success $commonAuditOptions | lpad | reportLine || failAndExit
AUSEARCH $auditDateOptions --raw | aulast --stdin | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Login/Logout (SUCCESS)" 
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Digital Media (mount/unmount)"
reportAndScreenLine "=== Description:  All events for portable media, be it"
reportAndScreenLine "===               mount, unmount, read, or write"
reportAndScreenLine "=== Note:         This audit requirement is difficult to"
reportAndScreenLine "===               satisfy under Linux with the native audit"
reportAndScreenLine "===               system.  If user-mountable drives are"
reportAndScreenLine "===               configured, your administrator should have"
reportAndScreenLine "===               auditd configured to watch those paths and"
reportAndScreenLine "===               this script modified to support it."
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.3 Export/Write to digital media [partial]" 
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.4 Import from digital media [partial]" 
reportLine          "Mounts of any filesystem"
reportLine          "------------------------"
AUSEARCH $auditDateOptions --format text --syscall mount| lpad | reportLine
reportLine          "Unmounts of any filesystem (compare to list above)"
reportLine          "--------------------------------------------------"
AUSEARCH $auditDateOptions --format text --file /usr/bin/umount| lpad | reportLine
reportLine          ""
reportLine          "Note that no file read or device writing was audited on this system" 
reportLine          "beyond that normally recorded everywhere on the system."
### if these RPMs are installed, recommend that audit rules be put in place
### if they aren't
reviewCdTools
echo "GlobalErrors=$GlobalErrors  GlobalWarnings=$GlobalWarnings"
reportAndScreenLine "=== AUDIT REPORT: Digital Media (mount/unmount)"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Local account management"
reportAndScreenLine "=== Description:  Users and groups added, deleted, or"
reportAndScreenLine "===               modified (Success/Failure)"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.5.(1) User add, delete, modify, disable (Success/Failure)" 
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.5.(2) Group add, delete, modify, disable (Success/Failure)" 
AUREPORT --mods $commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Local account management" 
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Configuration Changes (FAILED)"
reportAndScreenLine "=== Description:  Failed attempts to change files called out"
reportAndScreenLine "===               in the audit configuration"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.6.(1) Security or audit policy changes (Failure)" 
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.6.(2) Configuration changes (Failure)" 
AUREPORT --config --failed $commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Configuration Changes (FAILED)"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Configuration Changes (SUCCESS)"
reportAndScreenLine "=== Description:  Successful changes made to files called out"
reportAndScreenLine "===               in the audit configuration"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.6.(1) Security or audit policy changes (Success)" 
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.6.(2) Configuration changes (Success)" 
AUREPORT --config --success$commonAuditOptions | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Configuration Changes (SUCCESS)"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Login directly as root"
reportAndScreenLine "=== Description:  Detect when someone logs into the "
reportAndScreenLine "===               system as root (Success/Failure)"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.7 Admin or root-level access (Success/Failure)" 
uid0Users=$(awk 'BEGIN{FS=":"} $3 == "0" {print $1}' /etc/passwd)
if [ "$uid0Users" != "root" ]; then
   reportAndScreenLine "=== WARNING: UID 0 resolves to users other than \"root\": $(echo $uid0Users) "
   reportAndScreenLine "===          This script only checks for the \"root\" user."
fi
AUREPORT --login $commonAuditOptions | awk 'NR<6 {print} NR>1 && / root .*tty/ { print }' \
		| lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Login directly as root" 
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Privilege/role escalation"
reportAndScreenLine "=== Description:  Commands run by a user when they"
reportAndScreenLine "===               have taken on privileges"
reportAndScreenLine "=== Note:         Noisy commands issued during login are filtered out"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.8 Privilege/role escalation (Success/Failure)" 
AUREPORT --key privileged $commonAuditOptions --format text | \
		grep -v ' root, successfully executed /usr/sbin/unix_chkpwd' | \
		reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Privilege/role escalation"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Security relevant log data access (FAILURE)"
reportAndScreenLine "=== Description:  Report failed attempts to read the"
reportAndScreenLine "===               the audit log or the security log"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.9 Audit and security relevant log data access (Failure)" 
AUSEARCH  --success no $auditDateOptions --file /var/log/audit --file /var/log |\
		 reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Security log data access"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Security relevant log data access (SUCCESS)"
reportAndScreenLine "=== Description:  "
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.9 Audit and security relevant log data access (Success/Failure)" 
AUSEARCH  --success yes $auditDateOptions --file /var/log/audit --file /var/log | lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Security log data access"
reportLine          "" 

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: System start/shutdown"
reportAndScreenLine "=== Description:  Show the system booting, controlled shutdowns,"
reportAndScreenLine "===               runlevel changes (anything other than runlevel-3"
reportAndScreenLine "===               means that problems happened during boot),"
reportAndScreenLine "===               and audit daemon start/stop/reconfigure"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.10 System reboot, restart and shutdown (Success/Failure)" 
AUSEARCH $auditDateOptions -m SYSTEM_BOOT -m SYSTEM_SHUTDOWN -m SYSTEM_RUNLEVEL \
		-m DAEMON_START -m DAEMON_END -m DAEMON_CONFIG --format text | \
		reportLine || failAndExit
reportLine          "=== AUDIT REPORT: System start/shutdown "
reportLine          "" 

printSubsystemInstalled="no"
if [ -n "$(which lpq 2>/dev/null)" -o -n "$(which lpstat 2>/dev/null)" ]; then
   printSubsystemInstalled="yes"
fi
reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Print to a device or file:"
reportAndScreenLine "=== Description:  If printing is installed on this system,"
reportAndScreenLine "===               show something, but that code has not"
reportAndScreenLine "===               been writte yet.  See this page for ideas:"
reportAndScreenLine "===               https://www.cups.org/doc/accounting.html"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.11 Print to a device (Success/Failure)" 
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.12 Print to a file (Success/Failure)" 
if [ "$printSubsystemInstalled" == "no" ]; then
   reportAndScreenLine "=== Note:         You're in luck.  No printers are configured."
   reportAndScreenLine "===               There is nothing to audit."
else
   reportAndScreenLine "=== WARNING: Not implemented yet"
fi

reportAndScreenLine "=================================================" 
reportAndScreenLine "=== AUDIT REPORT: Commands Run"
reportAndScreenLine "=== Description:  STIG-identified commands that should be reviewed"
reportAndScreenLine "===               Filters are applied to remove systemd activity"
reportAndScreenLine "=== CNSS/JSIG:    AU-2.a.13 Application Initialization (Success/Failure)"
AUREPORT --comm $commonAuditOptions |egrep -v -e '(\(none\)|\? \?| abrt-cli | unix_chkpwd )'\
		| lpad | reportLine || failAndExit
reportLine          "=== AUDIT REPORT: Commands Run" 
reportAndScreenLine "=================================================" 
reportLine          "" 

reportAndScreenLine "=== CLEANING UP ==="
reportAndScreenLine "=== Compressing the extracted audit records"
gzip $auditArchiveFile

finalColor=${GREEN}
reportAndScreenLine "=== Counting up any errors or warnings"
echo "GlobalErrors=$GlobalErrors  GlobalWarnings=$GlobalWarnings"
if [ $GlobalErrors -ne 0 ]; then
   reportAndScreenLine "ALERT!  There were $GlobalErrors errors throughout this report."
   reportAndScreenLine "        This audit report is likely incomplete."
   reportAndScreenLine "        Failure to address these concerns will be noted"
   reportAndScreenLine "        during any incident response reviews."
   finalColor=${RED}
fi
if [ $GlobalWarnings -ne 0 ]; then
   reportAndScreenLine "NOTICE! Important warnings occurred while generating"
   reportAndScreenLine "        This report.  Please investigate."
   finalColor=${YELLOW}
fi

reportAndScreenLine "=== Advise the auditor on next steps"
echo "Now that the audit review is complete, feel free to force "
echo "a log rotation with"
echo "   sudo service auditd rotate"
echo "Review this report with"      
echo "   more $reportFile" 
echo "Archive the report and the original logs stored in"
echo "   $auditArchiveFile.gz"
if [ -n "$offlineArchiveFolder" -a -d "$offlineArchiveFolder" ] ; then
   echo ">>> Copying the report and archival copy of the supporting logs to"
   echo ">>> $offlineArchiveFolder"
   cp $reportFile $auditArchiveFile.gz $offlineArchiveFolder/. || failAndExit
   echo ">>> ${GREEN}Report archived${NO_COLOUR}"
fi
reportAndScreenLine "=== CLEAN UP COMPLETE ==="
reportAndScreenLine "${finalColor}=+=+=+=+=+=+=+=+ Audit Review Complete =+=+=+=+=+=+=+=+=+=${NO_COLOUR}"


##### UNCLASSIFIED ##########
#sudo aureport --key --interpret|egrep -v -e '(logins yes /usr/sbin/crond|modules yes /usr/bin/kmod|(access|delete|export|logins|modules|perm_mod|privileged) yes \? |logins yes /usr/bin/login -1)' 
#localUsers=$(echo $( getent passwd |grep -v nologin | cut -f1 -d:)  | sed -e 's/^/(/;s/$/)/;s/ /|/g;')
#auditusers=$(sudo ausearch --format csv |awk 'NR>2 {print}' | cut -d, -f9 |sort | uniq)
